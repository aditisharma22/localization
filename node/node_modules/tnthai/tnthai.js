doublearray = require("doublearray")
assert = require('assert')
fs = require('fs')
stopwords = require('stopwords-th')

function TNTrie(){
    var trie;
   
    data = fs.readFileSync(__dirname + "/bb","utf8")
    base_buffer = new Int32Array(data.split(","))
    data = fs.readFileSync(__dirname + "/cb","utf8")
    check_buffer = new Int32Array(data.split(","))
    trie = doublearray.load(base_buffer, check_buffer);

    this.prefixes = function(sentence){
        return trie.commonPrefixSearch(sentence)
    }
}

function ThaiAnalyzer(){
    var failSegmentRemainText = [];
    var globalResult = [];
    var result = [];
    var inputWord;
    var ascii_letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    var digits = "0123456789"
    var punctuation = "!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~"
    var printable = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&\'()*+,-./:;<=>?@[\\]^_`{|}~ \x0b\x0c"
    var whitespace = " "
    var trie = new TNTrie();
    var multipleSafeResult = true
    var modeFlag = "smart"
    var thai_unicode_char = 'กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะ ัาำ ิ ี ึ ื ุ ู ฺ ฿เแโใไๅๆ ็ ่ ้ ๊ ๋ ์ ํ ๐๑๒๓๔๕๖๗๘๙' + "\u0e4e\u0e4f\u0e5a\u0e5b";

    this.isLeadingChar = function(char){
        return thai_unicode_char.replace(" ","").includes(char)
    }

    this.segmenting = function(InputString, option){
            
        option = (typeof option !== 'undefined') ? option : { filterStopword : false, multiSolution : false, verbose : false }

        filterStopword = (typeof option.filterStopword !== 'undefined') ? option.filterStopword : false
        multiSolution = (typeof option.multiSolution !== 'undefined') ? option.multiSolution : false
        verbose = (typeof option.verbose !== 'undefined') ? option.verbose : false

        var Mode
        inputWord = InputString 
        segmentResults = []
        if (multiSolution){
            Mode = "Safe"
            this.safe_segment(InputString)
            failSegmentRemainText = []
            segmentResults = globalResult.slice(0)
        }
        if (segmentResults.length == 0){
            Mode = "Unsafe"
            this.unsafe_segment(InputString)
            segmentResults = globalResult.slice(0)
        }
        var segmentedResult;
        globalResult = []
        var segmentedSoln = []
        if (!multiSolution){
            segmentResults = [segmentResults[0]]
        }
        var FilteredResult = []
        if (filterStopword){
            segmentResults.map(function(solution){
                segmentedSoln = []
                solution.forEach(function(term){
                    if (!stopwords.includes(term)){
                        segmentedSoln.push(term)
                    }
                })
                FilteredResult.push(segmentedSoln.slice(0))
            })
            if(!multiSolution){
                segmentedResult = {solution:FilteredResult[0]}
            }
            else{
                segmentedResult = {solution:FilteredResult}
            }
        }
        else{
            if(!multiSolution){
                segmentedResult = {solution:segmentResults[0]}
            }
            else{
                segmentedResult = {solution:segmentResults}
            }
        }

        if (verbose){
            segmentedResult.push({Mode})
        }
        return segmentedResult
    }

    this.safe_segment = function(remainText){
        if (failSegmentRemainText.includes(remainText))
            return false;
        if (!multipleSafeResult)
            if (globalResult.length > 0)    
                return ;

        assert(result.join("") + remainText == inputWord)

        if (remainText.length > 0){
            var FirstChar = remainText[0]
            if (this.isLeadingChar(FirstChar)){
                var Prefixes = trie.prefixes(remainText)
                var resultOrCount = false
                for (var i = Prefixes.length - 1; i >= 0; i-- ){
                    var selectedPrefix = Prefixes[i]['k']
                    result.push(selectedPrefix)
                    suffixRemainText = remainText.substr(selectedPrefix.length)
                    var prefixResult = this.safe_segment(suffixRemainText)
                    result.pop()
                    resultOrCount = resultOrCount || prefixResult
                }

                if (!resultOrCount)
                    failSegmentRemainText.push(remainText)
            }
            else{
                if (printable.includes(FirstChar)){
                    if (punctuation.includes(FirstChar)){
                        var j = 0
                        while (punctuation.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.safe_segment(remainText.substr(j))
                        result.pop()
                    }
                    if (whitespace.includes(FirstChar)){
                        var j = 0
                        while (whitespace.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.safe_segment(remainText.substr(j))
                        result.pop()
                    }
                    if (digits.includes(FirstChar)){
                        var j = 0
                        while (digits.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.safe_segment(remainText.substr(j), trie)
                        result.pop()
                    }
                    if (ascii_letters.includes(FirstChar)){
                        var j = 0
                        while (ascii_letters.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.safe_segment(remainText.substr(j))
                        result.pop()
                    }
                }
                else{
                    result.push(remainText[0])
                    this.safe_segment(remainText.substr(1))
                    result.pop()
                }
            }
            
        }
        else{
            globalResult.push(result.slice(0))
            return true
        }
    }

    this.unsafe_segment = function(remainText){
        if (globalResult.length > 0)    
            return false;
        
        assert(result.join("") + remainText == inputWord)
       
        if (remainText.length > 0){
            var FirstChar = remainText[0]
            if (this.isLeadingChar(FirstChar)){
                Prefixes = trie.prefixes(remainText)
                for ( i = Prefixes.length-1; i >= 0; i-- ){
                    result.push(Prefixes[i]['k'])
                    this.unsafe_segment(remainText.substr(Prefixes[i]['k'].length))
                    result.pop()
                }
                var j = 0
                var unsafePrefixes = ""
                while( j < remainText.length){
                    Prefixes = trie.prefixes(remainText.substr(j))
                    j++
                    if (Prefixes.length > 0){
                        unsafePrefixes = remainText.substr(0,j-1)
                        break;
                    }
                    else{
                        unsafePrefixes = remainText.substr(0,j)
                    }
                    if (j == remainText.length){
                        unsafePrefixes = remainText
                        break
                    }
                    if (!this.isLeadingChar(remainText[j])){
                        unsafePrefixes = remainText.substr(0,j)
                        break
                    }
                }
                result.push(unsafePrefixes)
                this.unsafe_segment(remainText.substr(unsafePrefixes.length))
                result.pop()
            }
            else{
                if (printable.includes(FirstChar)){
                    if (punctuation.includes(FirstChar)){
                        var j = 0
                        while (punctuation.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.unsafe_segment(remainText.substr(j))
                        result.pop()
                    }
                    if (whitespace.includes(FirstChar)){
                        var j = 0
                        while (whitespace.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.unsafe_segment(remainText.substr(j))
                        result.pop()
                    }
                    if (digits.includes(FirstChar)){
                        var j = 0
                        while (digits.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.unsafe_segment(remainText.substr(j))
                        result.pop()
                    }
                    if (ascii_letters.includes(FirstChar)){
                        var j = 0
                        while (ascii_letters.includes(remainText[j])){
                            j+=1
                            if (remainText.length == j)
                                break;
                        }
                        result.push(remainText.substr(0,j))
                        this.unsafe_segment(remainText.substr(j))
                        result.pop()
                    }
                }
                else{
                    result.push(remainText[0])
                    this.unsafe_segment(remainText.substr(1))
                    result.pop()
                }
            }
        }
        else{
            globalResult.push(result.slice(0))
        }
    }
}

module.exports = ThaiAnalyzer
